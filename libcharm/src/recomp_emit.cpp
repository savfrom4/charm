#include "elfio/elf_types.hpp"
#include "libcharm/arm.hpp"
#include "libcharm/recomp.hpp"
#include "liblayer/liblayer.hpp"
#include <algorithm>
#include <cctype>
#include <cstdint>
#include <filesystem>
#include <iostream>
#include <sstream>
#include <stdexcept>
#include <string>

// to automatically exclude comments
#define MINIFY_COMMENT(x) (_minify ? "" : x)
#define MINIFY_COMMENT_COMMA(x) (_minify ? "," : x)

const std::array<std::string, (int)charm::arm::Opcode::COUNT> OPCODE_TABLE = {
    "ps.arm_and", "ps.arm_eor", "ps.arm_sub", "ps.arm_rsb",
    "ps.arm_add", "ps.arm_adc", "ps.arm_sbc", "ps.arm_rsc",
    "ps.arm_tst", "ps.arm_teq", "ps.arm_cmp", "ps.arm_cmn",
    "ps.arm_orr", "ps.arm_mov", "ps.arm_bic", "ps.arm_mvn",
};

const std::array<std::string, (int)charm::arm::Register::COUNT> REGISTER_TABLE =
    {
        "REG_R0",  "REG_R1", "REG_R2", "REG_R3", "REG_R4",  "REG_R5",
        "REG_R6",  "REG_R7", "REG_R8", "REG_R9", "REG_R10", "REG_R11",
        "REG_R12", "REG_SP", "REG_LR", "REG_PC",
};

const std::array<std::string, (int)charm::arm::Condition::COUNT> COND_TABLE = {
    "EQ", "NE", "CS", "CC", "MI", "PL", "VS", "VC",
    "HI", "LS", "GE", "LT", "GT", "LE", "AL", "NV",
};

const std::array<std::string, 4> SHIFT_TABLE = {
    "op2_lsl",
    "op2_lsr",
    "op2_asr",
    "op2_ror",
};

namespace charm::recomp {

std::string symbol_name_map(const std::string &symbol);
bool section_is_data(const ELFIO::section *section);
bool section_is_code(const ELFIO::section *section);

void Recompiler::step_emit(const std::string &output_dir) {
  const auto liblayer_path =
      std::filesystem::current_path() / "deps" / "liblayer";
  const auto symlink_path = std::filesystem::path{output_dir} / "liblayer";

  if (!std::filesystem::exists(liblayer_path)) {
    throw std::runtime_error(
        "Copy or symlink the \"liblayer\" directory from source "
        "to \"deps\" directory in current working direction.");
  }

  std::filesystem::create_directory(output_dir);

  if (!std::filesystem::exists(symlink_path)) {
    std::filesystem::create_symlink(liblayer_path, symlink_path);
  }

  emit_makefile(output_dir);

  std::cout << "> Code ..." << std::endl;
  emit_code_header(output_dir);
  emit_code_source(output_dir);

  std::cout << "> Data ..." << std::endl;
  emit_data_header(output_dir);
  emit_data_source(output_dir);
}

void Recompiler::emit_makefile(const std::string &output_dir) {
  auto makefile_path =
      std::filesystem::path{std::filesystem::path{output_dir} / "Makefile"};

  if (std::filesystem::exists(makefile_path)) {
    return;
  }

  std::ofstream ofs{makefile_path};

  ofs << "CXX ?= c++" << std::endl;
  ofs << "OPT = -O2" << std::endl;
  ofs << "CXXFLAGS = -Iliblayer/include -std=c++17 -flto -fPIC -w" << std::endl
      << std::endl;

  ofs << "SRCS = code.cpp data.cpp" << std::endl;
  ofs << "OBJS = $(SRCS:.cpp=.o)" << std::endl;
  ofs << "NAME = exec" << std::endl << std::endl;

  ofs << "STACK_BASE ?= " << LIBLAYER_STACK_BASE << std::endl;
  ofs << "STACK_SIZE ?= " << LIBLAYER_STACK_SIZE << std::endl;
  ofs << "DEBUG ?= 0" << std::endl;
  ofs << "SHARED ?= 0" << std::endl << std::endl;

  ofs << "CXXFLAGS += -DLIBLAYER_STACK_BASE=$(STACK_BASE) \\" << std::endl
      << "\t-DLIBLAYER_STACK_SIZE=$(STACK_SIZE)" << std::endl
      << std::endl;

  ofs << "ifeq ($(DEBUG),1)" << std::endl
      << "\tCXXFLAGS += -g -DLIBLAYER_DEBUG" << std::endl
      << "else" << std::endl
      << "\tCXXFLAGS += $(OPT)" << std::endl
      << "endif" << std::endl
      << std::endl;

  ofs << "ifeq ($(SHARED),1)" << std::endl
      << "\tCXXFLAGS += -shared" << std::endl
      << "\tEXEC := $(NAME).so" << std::endl
      << "else" << std::endl
      << "\tEXEC := $(NAME)" << std::endl
      << "endif" << std::endl
      << std::endl;

  ofs << ".PHONY: all clean" << std::endl;
  ofs << "all: $(EXEC)" << std::endl << std::endl;

  ofs << "$(EXEC): $(OBJS)" << std::endl;
  ofs << "\t$(CXX) $(CXXFLAGS) -o $@ $^" << std::endl << std::endl;

  ofs << "%.o:%.cpp" << std::endl;
  ofs << "\t$(CXX) $(CXXFLAGS) -c $< -o $@" << std::endl << std::endl;

  ofs << "clean:" << std::endl;
  ofs << "\trm -f $(OBJS) $(NAME) $(NAME).so" << std::endl;
}

void Recompiler::emit_code_header(const std::string &output_dir) {
  std::ofstream ofs{
      std::filesystem::path{std::filesystem::path{output_dir} / "code.hpp"},
  };

  ofs << "/* THIS FILE IS AUTO-GENERATED BY charm STATIC "
         "RECOMPILER! DO NOT "
         "MODIFY DIRECTLY! */"
      << std::endl;

  ofs << "#pragma once" << std::endl;
  ofs << "#include <liblayer/liblayer.hpp>" << std::endl << std::endl;

  ofs << "class ExecutionState : public ProgramState {" << std::endl;
  ofs << "public:" << std::endl;
  ofs << "\tuint32_t address_map(uintptr_t addr) override;" << std::endl;
  ofs << "\tuintptr_t address_resolve(uint32_t addr) override;" << std::endl;
  ofs << "};" << std::endl << std::endl;

  ofs << "void eval(ExecutionState& ps, uint32_t address);" << std::endl
      << std::endl;

  ofs << MINIFY_COMMENT("/* EXPORTED FUNCTIONS */") << std::endl << std::endl;

  for (auto &functions : _funs_exports) {
    ofs << "void internal_" << symbol_name_map(functions.second.name)
        << "(ExecutionState& ps);" << std::endl;
  }

  ofs << std::endl
      << MINIFY_COMMENT("/* DEPENDENCIES */") << std::endl
      << std::endl;

  for (auto &functions : _funs_deps) {
    if (!functions.second.is_external) {
      continue;
    }

    ofs << "void external_" << symbol_name_map(functions.second.name)
        << "(ExecutionState& ps);" << std::endl;
  }
}

void Recompiler::emit_code_source(const std::string &output_dir) {
  std::ofstream ofs{
      std::filesystem::path{std::filesystem::path{output_dir} / "code.cpp"},
  };

  ofs << "/* THIS FILE IS AUTO-GENERATED BY charm STATIC "
         "RECOMPILER! DO NOT "
         "MODIFY DIRECTLY! */"
      << std::endl;

  ofs << "#define LIBLAYER_IMPL" << std::endl;
  ofs << "#include <iostream>" << std::endl;
  ofs << "#include <stdexcept>" << std::endl;
  ofs << "#include <string>" << std::endl;
  ofs << "#include <liblayer/liblayer.hpp>" << std::endl;
  ofs << "#include \"code.hpp\"" << std::endl;
  ofs << "#include \"data.hpp\"" << std::endl << std::endl;
  ofs << "#define INSTR_RETURN_LR (0xFFFFFFFF)" << std::endl;
  ofs << "#define INSTR(ADDR) case ADDR: a##ADDR: ps.r[REG_PC] = ADDR+8;"
      << std::endl;

  ofs << std::endl
      << MINIFY_COMMENT("/* ADDRESS MAPPING */") << std::endl
      << std::endl;

  emit_code_address_mappings(ofs);
  emit_code_stubs(ofs);

  ofs << "void eval(ExecutionState& ps, uint32_t address) {" << std::endl;
  ofs << "__start__:" << std::endl;
  ofs << "\tswitch(address) {" << std::endl;

  ofs << MINIFY_COMMENT(
             "\t// this is a special address that is used to return out of "
             "function when PC is set it.")
      << std::endl;

  ofs << "\tINSTR(INSTR_RETURN_LR) {" << std::endl;
  ofs << "\t\treturn;" << std::endl;
  ofs << "\t}" << std::endl << std::endl;

  for (auto &section : _elf.sections) {
    if (!section_is_code(section.get())) {
      continue;
    }

    emit_code_section(ofs, section.get());
  }

  ofs << "\tdefault:" << std::endl;

  if (_minify) {
    ofs << "\t\t__builtin_unreachable();";
  } else {
    ofs << "\t\tthrow std::runtime_error(\"Invalid address: \" + "
           "std::to_string(address));";
  }

  ofs << std::endl << "\t}" << std::endl << "}" << std::endl;
}

void Recompiler::emit_data_header(const std::string &output_dir) {
  std::ofstream ofs{
      std::filesystem::path{std::filesystem::path{output_dir} / "data.hpp"},
  };

  ofs << "/* THIS FILE IS AUTO-GENERATED BY charm STATIC "
         "RECOMPILER! DO NOT "
         "MODIFY DIRECTLY! */"
      << std::endl;

  ofs << "#pragma once" << std::endl;
  ofs << "#include <cstdint>" << std::endl << std::endl;

  for (auto &section : _elf.sections) {
    if (!section_is_data(section.get())) {
      continue;
    }

    auto name = symbol_name_map(section->get_name());
    std::transform(name.begin(), name.end(), name.begin(), ::toupper);

    if (section->get_name().find(".got") == std::string::npos) {
      ofs << ((section->get_flags() & ELFIO::SHF_WRITE)
                  ? "extern uint8_t g_"
                  : "extern const uint8_t g_");

      ofs << name << "_DATA[" << section->get_size() << "];" << std::endl;
    } else {
      ofs << ((section->get_flags() & ELFIO::SHF_WRITE)
                  ? "extern uint32_t g_"
                  : "extern const uint32_t g_");

      ofs << name << "_DATA[" << (section->get_size() / sizeof(uint32_t))
          << "];" << std::endl;
    }

    ofs << "#define " << name << "_ADDR (0x" << std::hex
        << section->get_address() << std::dec << ") /* Virtual address of "
        << section->get_name() << " */" << std::endl;

    ofs << "#define " << name << "_SIZE (" << section->get_size()
        << ") /* Size of " << section->get_name() << " */ " << std::endl
        << std::endl;
  }
}

void Recompiler::emit_data_source(const std::string &output_dir) {
  std::ofstream ofs{
      std::filesystem::path{std::filesystem::path{output_dir} / "data.cpp"},
  };

  ofs << "/* THIS FILE IS AUTO-GENERATED BY charm STATIC "
         "RECOMPILER! DO NOT "
         "MODIFY DIRECTLY! */"
      << std::endl;

  ofs << "#include \"data.hpp\"" << std::endl << std::endl;

  for (auto &section : _elf.sections) {
    if (!section_is_data(section.get())) {
      continue;
    }

    const uint8_t *data =
        reinterpret_cast<const uint8_t *>(section->get_data());

    auto name = symbol_name_map(section->get_name());
    std::transform(name.begin(), name.end(), name.begin(), ::toupper);

    std::stringstream ss;

    // for non-got table we just write raw bytes or 0es
    if (section->get_name().find(".got") == std::string::npos) {
      ofs << ((section->get_flags() & ELFIO::SHF_WRITE) ? "uint8_t g_"
                                                        : "const uint8_t g_");

      ofs << name << "_DATA[" << section->get_size() << "] = {" << std::endl;

      ss << "\t";
      for (size_t i = 0; i < section->get_size(); i++) {
        ss << (data ? static_cast<int>(data[i]) : 0) << ", ";

        if (i % 8 == 7) {
          ss << std::endl;
          ss << "\t";
        }
      }
    } else { // for got we map addresses that we know
      ofs << ((section->get_flags() & ELFIO::SHF_WRITE) ? "uint32_t g_"
                                                        : "const uint32_t g_");

      ofs << name << "_DATA[" << (section->get_size() / sizeof(uint32_t))
          << "] = {" << std::endl;

      ss << std::hex;

      // map addresses
      for (size_t i = 0; i < section->get_size(); i += sizeof(uint32_t)) {
        uintptr_t mapped_address = 0;

        for (auto &mapping : _got_mappings) {
          uintptr_t offset = std::get<0>(mapping) - section->get_address();
          if (offset != i) {
            continue;
          }

          mapped_address = std::get<1>(mapping);
          break;
        }

        ss << "\t0x" << mapped_address << "," << std::endl;
      }

      ss << std::dec;
    }

    ofs << ss.rdbuf() << std::endl << "};" << std::endl;
  }
}

void Recompiler::emit_code_address_mappings(std::ofstream &ofs) {
  ofs << "inline uint32_t ExecutionState::address_map(uintptr_t addr) {"
      << std::endl;

  // stack first because most most frequent access
  ofs << "\tif(addr >= reinterpret_cast<uintptr_t>(stack) && addr < "
         "reinterpret_cast<uintptr_t>(stack) + "
         "LIBLAYER_STACK_SIZE) {"
      << std::endl;
  ofs << "\t\treturn LIBLAYER_STACK_BASE + static_cast<uint32_t>("
      << "addr - reinterpret_cast<uintptr_t>(stack));" << std::endl;

  ofs << "\t}" << std::endl;

  for (auto &section : _elf.sections) {
    if (!section_is_data(section.get())) {
      continue;
    }

    auto name = symbol_name_map(section->get_name());
    std::transform(name.begin(), name.end(), name.begin(), ::toupper);

    ofs << std::hex;
    ofs << "\tif(addr >= reinterpret_cast<uintptr_t>(g_" << name << "_DATA)"
        << " && addr < reinterpret_cast<uintptr_t>(g_" << name << "_DATA) + "
        << name << "_SIZE) {" << std::endl;
    ofs << "\t\treturn 0x" << (uint32_t)section->get_address()
        << " + static_cast<uint32_t>("
        << "addr - reinterpret_cast<uintptr_t>(g_" << name << "_DATA));"
        << std::endl;

    ofs << std::dec << "\t}" << std::endl;
  }

  ofs << "}" << std::endl << std::endl;

  ofs << "inline uintptr_t ExecutionState::address_resolve(uint32_t addr) {"
      << std::endl;

  ofs << std::hex;

  // stack first because most most frequent access
  ofs << "\tif(addr >= LIBLAYER_STACK_BASE && addr < LIBLAYER_STACK_BASE + "
         "LIBLAYER_STACK_SIZE) {"
      << std::endl;
  ofs << "\t\treturn reinterpret_cast<uintptr_t>(&stack[addr - "
         "LIBLAYER_STACK_BASE]);"
      << std::endl;

  ofs << "\t}" << std::endl;

  for (auto &section : _elf.sections) {
    if (!section_is_data(section.get())) {
      continue;
    }

    auto name = symbol_name_map(section->get_name());
    std::transform(name.begin(), name.end(), name.begin(), ::toupper);

    ofs << "\tif(addr >= 0x" << section->get_address() << " && addr < 0x"
        << section->get_address() + section->get_size() << ") {" << std::endl;
    ofs << "\t\treturn reinterpret_cast<uintptr_t>(&reinterpret_cast<const "
           "char*>(g_"
        << name << "_DATA)[addr - 0x" << section->get_address() << "]);"
        << std::endl;

    ofs << "\t}" << std::endl;
  }

  ofs << std::dec;
  ofs << "}" << std::endl << std::endl;
}

void Recompiler::emit_code_stubs(std::ofstream &ofs) {

  ofs << std::endl
      << MINIFY_COMMENT("/* EXPORTED FUNCTIONS */") << std::endl
      << std::endl;

  for (auto &functions : _funs_exports) {
    ofs << "__attribute__((weak)) void internal_"
        << symbol_name_map(functions.second.name) << "(ExecutionState& ps) {"
        << std::endl;

    // We need to set LR to INSTR_RETURN_LR for functions to return back
    // properly!
    ofs << "\tps.r[REG_LR] = INSTR_RETURN_LR;" << std::endl;

    // Vinaly
    ofs << "\teval(ps, 0x" << std::hex << functions.second.address << std::dec
        << ");" << std::endl;

    ofs << "}" << std::endl << std::endl;
  }

  ofs << std::endl
      << MINIFY_COMMENT("/* DEPENDENCY STUBS */") << std::endl
      << std::endl;

  for (auto &functions : _funs_deps) {
    if (!functions.second.is_external) {
      continue;
    }

    ofs << "__attribute__((weak)) void external_" << functions.second.name
        << "(ExecutionState& ps) {" << std::endl;
    ofs << "\tstd::cout << \"stub: " << symbol_name_map(functions.second.name)
        << "\" << std::endl;" << std::endl;
    ofs << "}" << std::endl << std::endl;
  }
}

void Recompiler::emit_code_section(std::ofstream &ofs,
                                   const ELFIO::section *section) {
  if (!section)
    return;

  std::cout << "\tSection " << section->get_name() << " ..." << std::endl;

  const auto data = section->get_data();
  const auto data_size = section->get_size();

  if (!data) {
    return;
  }

  if (!_minify) {
    ofs << std::endl
        << "/* SECTION " << section->get_name() << " */" << std::endl;
  }

  std::stringstream ss;

  // actual emit
  for (size_t i = 0; i < data_size; i += sizeof(uint32_t)) {
    uintptr_t addr = section->get_address() + i;

    ss << std::hex << "\tINSTR(0x" << addr << ") {" << std::dec << std::endl;

    uint32_t instr_raw;
    memcpy(&instr_raw, data + i, sizeof(uint32_t));
    auto instr = arm::Instruction::decode(instr_raw);

    // debug information for instruction debugging

    if (!_minify) {
      ss << "\t\t" << COND_TABLE[(int)instr.cond] << "(";
      ss << "DEBUG_LOG(\"0x" << std::hex << addr << ": ";
      instr.dump(ss);
      ss << "\"));" << std::endl;
    }

    // now actual instruction
    emit_code_arm(ss, instr, addr);

    ss << "\t\t[[fallthrough]];" << std::endl
       << "\t}" << std::endl
       << std::endl;
  }

  if (_minify) {
    std::string minimized_ss = ss.str();
    minimized_ss.erase(
        std::remove_if(minimized_ss.begin(), minimized_ss.end(),
                       [](char c) { return isspace(c) && c != ' '; }),
        minimized_ss.end());

    ofs << minimized_ss;
  } else {
    ofs << ss.rdbuf();
  }
}

void Recompiler::emit_code_arm(std::ostream &os, arm::Instruction &instr,
                               uintptr_t address) {
  if (instr.group == arm::InstructionGroup::INVALID) {
    if (_minify) {
      os << "\t\t__builtin_unreachable();";
    } else {
      os << "\t\tthrow std::runtime_error(\"Illegal instruction at 0x"
         << std::hex << address << std::dec << "\");";
    }
    return;
  }

  os << "\t\t" << COND_TABLE[(int)instr.cond] << "(";

  switch (instr.group) {
  case arm::InstructionGroup::DATA_PROCESSING: {
    if (instr.is_imm) {
      os << OPCODE_TABLE[(int)instr.data.op] << "("
         << (instr.set_cond ? "true" : "false")
         << MINIFY_COMMENT_COMMA(" /* set_cond */, ")

         << REGISTER_TABLE[(int)instr.data.rd]
         << MINIFY_COMMENT_COMMA(" /* rd */, ")

         << REGISTER_TABLE[(int)instr.data.rn]
         << MINIFY_COMMENT_COMMA(" /* rn */, ")

         << "0x" << std::hex << instr.data.op2_imm << std::dec
         << MINIFY_COMMENT(" /* op2_imm */") << ");";
      break;
    }

    if (instr.data.op2_reg.is_reg) {
      os << OPCODE_TABLE[(int)instr.data.op] << "("
         << (instr.set_cond ? "true" : "false")
         << MINIFY_COMMENT_COMMA(" /* set_cond */, ")

         << REGISTER_TABLE[(int)instr.data.rd]
         << MINIFY_COMMENT_COMMA(" /* rd */, ")

         << REGISTER_TABLE[(int)instr.data.rn]
         << MINIFY_COMMENT_COMMA(" /* rn */, ")

         << SHIFT_TABLE[(int)instr.data.op2_reg.type] << "(ps.r["

         << REGISTER_TABLE[(int)instr.data.op2_reg.rm] << "]"
         << MINIFY_COMMENT_COMMA(" /* rm */, ")

         << "ps.r[" << REGISTER_TABLE[(int)instr.data.op2_reg.amount_or_rs]
         << "]" << MINIFY_COMMENT(" /* rs */") << "));";

    } else {
      os << OPCODE_TABLE[(int)instr.data.op] << "("
         << (instr.set_cond ? "true" : "false")
         << MINIFY_COMMENT_COMMA(" /* set_cond */, ")

         << REGISTER_TABLE[(int)instr.data.rd]
         << MINIFY_COMMENT_COMMA(" /* rd */, ")

         << REGISTER_TABLE[(int)instr.data.rn]
         << MINIFY_COMMENT_COMMA(" /* rn */, ")

         << SHIFT_TABLE[(int)instr.data.op2_reg.type] << "(ps.r["

         << REGISTER_TABLE[(int)instr.data.op2_reg.rm] << "]"
         << MINIFY_COMMENT_COMMA(" /* rm */, ")

         << "0x" << std::hex << (uint32_t)instr.data.op2_reg.amount_or_rs
         << std::dec << MINIFY_COMMENT(" /* amount */") << "));";
    }

    switch (instr.data.op) {
    case arm::Opcode::TST:
    case arm::Opcode::TEQ:
    case arm::Opcode::CMP:
    case arm::Opcode::CMN:
    case arm::Opcode::BIC:
    case arm::Opcode::COUNT:
    case arm::Opcode::INVALID:
      break;

    default: {
      if (instr.data.rd != arm::Register::PC) {
        break;
      }

      os << " address = " << std::hex << "ps.r[" << REGISTER_TABLE[REG_PC]
         << "]; goto __start__;";

      os << MINIFY_COMMENT(" /* this instruction modifies pc */");
      break;
    }
    }

    break;
  }

  case arm::InstructionGroup::MULTIPLY:
    os << (instr.mul.accumulate ? "ps.arm_mla" : "ps.arm_mul") << "("
       << (instr.set_cond ? "true" : "false")
       << MINIFY_COMMENT_COMMA(" /* set_cond */, ")

       << REGISTER_TABLE[(int)instr.mul.rd]
       << MINIFY_COMMENT_COMMA(" /* rd */, ")

       << REGISTER_TABLE[(int)instr.mul.rn]
       << MINIFY_COMMENT_COMMA(" /* rn */, ")

       << REGISTER_TABLE[(int)instr.mul.rs]
       << MINIFY_COMMENT_COMMA(" /* rs */, ")

       << REGISTER_TABLE[(int)instr.mul.rm] << MINIFY_COMMENT(" /* rm */")
       << ")";
    break;

  case arm::InstructionGroup::MULTIPLY_LONG:
    os << (instr.mul_long.accumulate ? "ps.arm_mlal" : "ps.arm_mull") << "("
       << (instr.set_cond ? "true" : "false")
       << MINIFY_COMMENT_COMMA(" /* set_cond */, ")

       << (instr.mul_long.sign ? "true" : "false")
       << MINIFY_COMMENT_COMMA(" /* sign */, ")

       << REGISTER_TABLE[(int)instr.mul_long.rd_lo]
       << MINIFY_COMMENT_COMMA(" /* rn_lo */, ")

       << REGISTER_TABLE[(int)instr.mul_long.rd_hi]
       << MINIFY_COMMENT_COMMA(" /* rd_hi */, ")

       << REGISTER_TABLE[(int)instr.mul_long.rm]
       << MINIFY_COMMENT_COMMA(" /* rm */, ")

       << REGISTER_TABLE[(int)instr.mul_long.rs] << MINIFY_COMMENT(" /* rs */")
       << ")";
    break;

  case arm::InstructionGroup::BRANCH: {
    uint32_t final_offset = (int64_t)(address + 8) + instr.branch.offset;
    Function *mapped = nullptr;

    // check if maybe we are calling external fn
    if (_fun_deps_mapped.count(final_offset)) {
      mapped = _fun_deps_mapped[final_offset];

      if (mapped->is_external) {
        os << "external_" << mapped->name << "(ps)";

        if (!instr.branch.link) {
          os << MINIFY_COMMENT(" /* b, not bl */");
        }

        break;
      }

      final_offset = mapped->address;
    }

    bool found_section = false;
    for (auto &section : _elf.sections) {
      if (!section_is_code(section.get())) {
        continue;
      }

      if (final_offset < section->get_address() ||
          final_offset >= section->get_address() + section->get_size()) {
        continue;
      }

      found_section = true;
      break;
    }

    if (!found_section) {
      os << "throw std::runtime_error(\"Invald b/bl address: 0x" << std::hex
         << final_offset << std::dec << "\")";
      break;
    }

    if (instr.branch.link) {
      os << "ps.r[REG_LR] = 0x" << std::hex << address + sizeof(uint32_t)
         << std::dec << "; ";
    }

    os << "goto a0x" << std::hex << final_offset << std::dec;

    if (!_minify && mapped) {
      os << " /* ref: " << mapped->name << " */";
    }

    break;
  }

  case arm::InstructionGroup::BRANCH_EXCHANGE:
    os << "address = " << std::hex << "ps.r["
       << REGISTER_TABLE[(int)instr.branchex.rm] << "]; goto __start__; "
       << MINIFY_COMMENT("/* bx */");
    break;

  case arm::InstructionGroup::SINGLE_DATA_SWAP:
    os << "throw "
          "std::runtime_error(\"SINGLE_DATA_SWAP instruction at 0x"
       << std::hex << address << std::dec << "\")";
    break;

  case arm::InstructionGroup::SINGLE_DATA_TRANSFER:
    os << (instr.data_trans.load ? "ps.arm_ldr(" : "ps.arm_str(")

       << (instr.data_trans.pre_indx ? "true" : "false")
       << MINIFY_COMMENT_COMMA(" /* pre_indx */, ")

       << (instr.data_trans.add ? "true" : "false")
       << MINIFY_COMMENT_COMMA(" /* add */, ")

       << (instr.data_trans.byte ? "true" : "false")
       << MINIFY_COMMENT_COMMA(" /* byte */, ")

       << (instr.data_trans.write_back ? "true" : "false")
       << MINIFY_COMMENT_COMMA(" /* write_back */, ")

       << REGISTER_TABLE[(int)instr.data_trans.rn]
       << MINIFY_COMMENT_COMMA(" /* rn */, ")

       << REGISTER_TABLE[(int)instr.data_trans.rd]
       << MINIFY_COMMENT_COMMA(" /* rd */, ");

    os << std::hex;

    if (instr.is_imm) {
      os << "0x" << (int)instr.data_trans.offset_imm
         << MINIFY_COMMENT(" /* offset */");
    } else {
      if (instr.data_trans.offset_reg.is_reg) {
        os << SHIFT_TABLE[(int)instr.data_trans.offset_reg.type] << "(ps.r["
           << REGISTER_TABLE[(int)instr.data_trans.offset_reg.rm] << "]"
           << MINIFY_COMMENT_COMMA(" /* rm */,")

           << "ps.r["
           << REGISTER_TABLE[(int)instr.data_trans.offset_reg.amount_or_rs]
           << "]" << MINIFY_COMMENT(" /* rs */") << ")";
      } else {
        os << SHIFT_TABLE[(int)instr.data_trans.offset_reg.type] << "(ps.r["

           << REGISTER_TABLE[(int)instr.data_trans.offset_reg.rm] << "]"
           << MINIFY_COMMENT_COMMA(" /* rm */,")

           << "0x" << std::hex
           << (uint32_t)instr.data_trans.offset_reg.amount_or_rs << std::dec
           << MINIFY_COMMENT(" /* amount */") << ")";
      }
    }

    os << std::dec;
    os << ", true" << MINIFY_COMMENT(" /* copy */") << ");";

    if (instr.data_trans.load) {
      if (instr.data_trans.rd != arm::Register::PC) {
        break;
      }

      os << " address = " << std::hex << "ps.r[" << REGISTER_TABLE[REG_PC]
         << "]; goto __start__;";

      os << MINIFY_COMMENT(" /* this instruction modifies pc */");
    }

    break;

  case arm::InstructionGroup::BLOCK_DATA_TRANSFER: {
    os << (instr.blk_data_trans.load ? "ps.arm_ldm(" : "ps.arm_stm(")
       << (instr.blk_data_trans.pre_indx ? "true" : "false")
       << MINIFY_COMMENT_COMMA(" /* pre_indx */, ")

       << (instr.blk_data_trans.add ? "true" : "false")
       << MINIFY_COMMENT_COMMA(" /* add */, ")

       << (instr.blk_data_trans.write_back ? "true" : "false")
       << MINIFY_COMMENT_COMMA(" /* write_back */, ")

       << REGISTER_TABLE[(int)instr.blk_data_trans.rn]
       << MINIFY_COMMENT_COMMA(" /* rn */, ") << std::hex << "0x"

       << instr.blk_data_trans.reg_list << std::dec
       << MINIFY_COMMENT_COMMA(" /* reg_list */, ") << "true"
       << MINIFY_COMMENT(" /* copy */") << ");";

    if (instr.blk_data_trans.load) {
      if (!((instr.blk_data_trans.reg_list >> REG_PC) & 1)) {
        break;
      }

      os << " address = " << std::hex << "ps.r[" << REGISTER_TABLE[REG_PC]
         << "]; goto __start__;";

      os << MINIFY_COMMENT(" /* this instruction modifies pc */");
    }

    break;
  }

  case arm::InstructionGroup::HALFWORD_DATA_TRANSFER:
    os << (instr.hw_data_trans.load ? "ps.arm_ldrh(" : "ps.arm_strh(")
       << (instr.hw_data_trans.pre_indx ? "true" : "false")
       << MINIFY_COMMENT_COMMA(" /* pre_indx */, ")

       << (instr.hw_data_trans.add ? "true" : "false")
       << MINIFY_COMMENT_COMMA(" /* add */, ")

       << (instr.hw_data_trans.write_back ? "true" : "false")
       << MINIFY_COMMENT_COMMA(" /* write_back */, ")

       << REGISTER_TABLE[(int)instr.hw_data_trans.rn]
       << MINIFY_COMMENT_COMMA(" /* rn */, ")

       << REGISTER_TABLE[(int)instr.hw_data_trans.rd]
       << MINIFY_COMMENT_COMMA(" /* rd */, ")

       << "0x" << std::hex << (int)instr.hw_data_trans.type
       << MINIFY_COMMENT_COMMA(" /* type */, ");

    if (instr.is_imm) {
      os << "0x" << (int)instr.hw_data_trans.offset_imm
         << MINIFY_COMMENT(" /* offset */");
    } else {
      os << REGISTER_TABLE[(int)instr.hw_data_trans.rm]
         << MINIFY_COMMENT(" /* rm */");
    }

    // TODO: fix this

    os << std::dec << ")";
    break;

  case arm::InstructionGroup::SWI:
    os << MINIFY_COMMENT("/* swi */");
    break;

  default:
    __builtin_unreachable();
  }

  os << ");" << std::endl;
}

inline std::string symbol_name_map(const std::string &symbol) {
  std::string s;

  for (auto &ch : symbol) {
    if (isspace(ch)) {
      s += '_';
      continue;
    }

    if (!isalpha(ch) && !isdigit(ch) && ch != '_') {
      continue;
    }

    s += ch;
  }

  return s;
}

inline bool section_is_data(const ELFIO::section *section) {
  auto flags = section->get_flags();
  if (!(flags & ELFIO::SHF_ALLOC) && !(flags & ELFIO::SHF_EXECINSTR)) {
    return false;
  }

  auto type = section->get_type();
  if (type == ELFIO::SHT_SYMTAB || type == ELFIO::SHT_DYNSYM ||
      type == ELFIO::SHT_RELA) {
    return false;
  }

  if (section->get_name().find("plt") != std::string::npos) {
    return false;
  }

  if (section->get_name().find("padding") != std::string::npos) {
    return false;
  }

  if (!section->get_size()) {
    return false;
  }

  return true;
}

inline bool section_is_code(const ELFIO::section *section) {
  if (!(section->get_flags() & ELFIO::SHF_EXECINSTR)) {
    return false;
  }

  if (section->get_name().find("plt") != std::string::npos) {
    return false;
  }

  if (!section->get_data()) {
    return false;
  }

  return true;
}

} // namespace charm::recomp
